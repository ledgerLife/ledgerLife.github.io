"use strict";function getSide(e){return e.split("-")[0]}function getAlignment(e){return e.split("-")[1]}function getMainAxisFromPlacement(e){return["top","bottom"].includes(getSide(e))?"x":"y"}function getLengthFromAxis(e){return"y"===e?"height":"width"}function computeCoordsFromPlacement(e,t,n){let{reference:i,floating:o}=e;const r=i.x+i.width/2-o.width/2,l=i.y+i.height/2-o.height/2,a=getMainAxisFromPlacement(t),s=getLengthFromAxis(a),c=i[s]/2-o[s]/2,f="x"===a;let m;switch(getSide(t)){case"top":m={x:r,y:i.y-o.height};break;case"bottom":m={x:r,y:i.y+i.height};break;case"right":m={x:i.x+i.width,y:l};break;case"left":m={x:i.x-o.width,y:l};break;default:m={x:i.x,y:i.y}}switch(getAlignment(t)){case"start":m[a]-=c*(n&&f?-1:1);break;case"end":m[a]+=c*(n&&f?-1:1)}return m}Object.defineProperty(exports,"__esModule",{value:!0});const computePosition=async(e,t,n)=>{const{placement:i="bottom",strategy:o="absolute",middleware:r=[],platform:l}=n,a=await(null==l.isRTL?void 0:l.isRTL(t));if("production"!==process.env.NODE_ENV&&(null==l&&console.error(["Floating UI: `platform` property was not passed to config. If you","want to use Floating UI on the web, install @floating-ui/dom","instead of the /core package. Otherwise, you can create your own","`platform`: https://floating-ui.com/docs/platform"].join(" ")),r.filter((e=>{let{name:t}=e;return"autoPlacement"===t||"flip"===t})).length>1))throw new Error(["Floating UI: duplicate `flip` and/or `autoPlacement`","middleware detected. This will lead to an infinite loop. Ensure only","one of either has been passed to the `middleware` array."].join(" "));let s=await l.getElementRects({reference:e,floating:t,strategy:o}),{x:c,y:f}=computeCoordsFromPlacement(s,i,a),m=i,d={};const g=new Set;let p=0;for(let u=0;u<r.length;u++){if("production"!==process.env.NODE_ENV&&(p++,p>100))throw new Error(["Floating UI: The middleware lifecycle appears to be","running in an infinite loop. This is usually caused by a `reset`","continually being returned without a break condition."].join(" "));const{name:n,fn:h}=r[u];if(g.has(n))continue;const{x:x,y:y,data:w,reset:v}=await h({x:c,y:f,initialPlacement:i,placement:m,strategy:o,middlewareData:d,rects:s,platform:l,elements:{reference:e,floating:t}});c=null!=x?x:c,f=null!=y?y:f,d={...d,[n]:{...d[n],...w}},v&&("object"===typeof v&&(v.placement&&(m=v.placement),v.rects&&(s=!0===v.rects?await l.getElementRects({reference:e,floating:t,strategy:o}):v.rects),({x:c,y:f}=computeCoordsFromPlacement(s,m,a)),!1!==v.skip&&g.add(n)),u=-1)}return{x:c,y:f,placement:m,strategy:o,middlewareData:d}};function expandPaddingObject(e){return{top:0,right:0,bottom:0,left:0,...e}}function getSideObjectFromPadding(e){return"number"!==typeof e?expandPaddingObject(e):{top:e,right:e,bottom:e,left:e}}function rectToClientRect(e){return{...e,top:e.y,left:e.x,right:e.x+e.width,bottom:e.y+e.height}}async function detectOverflow(e,t){var n;void 0===t&&(t={});const{x:i,y:o,platform:r,rects:l,elements:a,strategy:s}=e,{boundary:c="clippingAncestors",rootBoundary:f="viewport",elementContext:m="floating",altBoundary:d=!1,padding:g=0}=t,p=getSideObjectFromPadding(g),u=a[d?"floating"===m?"reference":"floating":m],h=rectToClientRect(await r.getClippingRect({element:null==(n=await(null==r.isElement?void 0:r.isElement(u)))||n?u:u.contextElement||await(null==r.getDocumentElement?void 0:r.getDocumentElement(a.floating)),boundary:c,rootBoundary:f})),x=rectToClientRect(r.convertOffsetParentRelativeRectToViewportRelativeRect?await r.convertOffsetParentRelativeRectToViewportRelativeRect({rect:"floating"===m?{...l.floating,x:i,y:o}:l.reference,offsetParent:await(null==r.getOffsetParent?void 0:r.getOffsetParent(a.floating)),strategy:s}):l[m]);return{top:h.top-x.top+p.top,bottom:x.bottom-h.bottom+p.bottom,left:h.left-x.left+p.left,right:x.right-h.right+p.right}}const min=Math.min,max=Math.max;function within(e,t,n){return max(e,min(t,n))}const arrow=e=>({name:"arrow",options:e,async fn(t){const{element:n,padding:i=0}=null!=e?e:{},{x:o,y:r,placement:l,rects:a,platform:s}=t;if(null==n)return"production"!==process.env.NODE_ENV&&console.warn("Floating UI: No `element` was passed to the `arrow` middleware."),{};const c=getSideObjectFromPadding(i),f={x:o,y:r},m=getMainAxisFromPlacement(l),d=getLengthFromAxis(m),g=await s.getDimensions(n),p="y"===m?"top":"left",u="y"===m?"bottom":"right",h=a.reference[d]+a.reference[m]-f[m]-a.floating[d],x=f[m]-a.reference[m],y=await(null==s.getOffsetParent?void 0:s.getOffsetParent(n)),w=y?"y"===m?y.clientHeight||0:y.clientWidth||0:0,v=h/2-x/2,b=c[p],P=w-g[d]-c[u],A=w/2-g[d]/2+v,O=within(b,A,P);return{data:{[m]:O,centerOffset:A-O}}}}),hash$1={left:"right",right:"left",bottom:"top",top:"bottom"};function getOppositePlacement(e){return e.replace(/left|right|bottom|top/g,(e=>hash$1[e]))}function getAlignmentSides(e,t,n){void 0===n&&(n=!1);const i=getAlignment(e),o=getMainAxisFromPlacement(e),r=getLengthFromAxis(o);let l="x"===o?i===(n?"end":"start")?"right":"left":"start"===i?"bottom":"top";return t.reference[r]>t.floating[r]&&(l=getOppositePlacement(l)),{main:l,cross:getOppositePlacement(l)}}const hash={start:"end",end:"start"};function getOppositeAlignmentPlacement(e){return e.replace(/start|end/g,(e=>hash[e]))}const sides=["top","right","bottom","left"],allPlacements=sides.reduce(((e,t)=>e.concat(t,t+"-start",t+"-end")),[]);function getPlacementList(e,t,n){return(e?[...n.filter((t=>getAlignment(t)===e)),...n.filter((t=>getAlignment(t)!==e))]:n.filter((e=>getSide(e)===e))).filter((n=>!e||(getAlignment(n)===e||!!t&&getOppositeAlignmentPlacement(n)!==n)))}const autoPlacement=function(e){return void 0===e&&(e={}),{name:"autoPlacement",options:e,async fn(t){var n,i,o,r,l;const{x:a,y:s,rects:c,middlewareData:f,placement:m,platform:d,elements:g}=t,{alignment:p=null,allowedPlacements:u=allPlacements,autoAlignment:h=!0,...x}=e,y=getPlacementList(p,h,u),w=await detectOverflow(t,x),v=null!=(n=null==(i=f.autoPlacement)?void 0:i.index)?n:0,b=y[v],{main:P,cross:A}=getAlignmentSides(b,c,await(null==d.isRTL?void 0:d.isRTL(g.floating)));if(m!==b)return{x:a,y:s,reset:{skip:!1,placement:y[0]}};const O=[w[getSide(b)],w[P],w[A]],R=[...null!=(o=null==(r=f.autoPlacement)?void 0:r.overflows)?o:[],{placement:b,overflows:O}],S=y[v+1];if(S)return{data:{index:v+1,overflows:R},reset:{skip:!1,placement:S}};const F=R.slice().sort(((e,t)=>e.overflows[0]-t.overflows[0])),T=null==(l=F.find((e=>{let{overflows:t}=e;return t.every((e=>e<=0))})))?void 0:l.placement;return{reset:{placement:null!=T?T:F[0].placement}}}}};function getExpandedPlacements(e){const t=getOppositePlacement(e);return[getOppositeAlignmentPlacement(e),t,getOppositeAlignmentPlacement(t)]}const flip=function(e){return void 0===e&&(e={}),{name:"flip",options:e,async fn(t){var n;const{placement:i,middlewareData:o,rects:r,initialPlacement:l,platform:a,elements:s}=t,{mainAxis:c=!0,crossAxis:f=!0,fallbackPlacements:m,fallbackStrategy:d="bestFit",flipAlignment:g=!0,...p}=e,u=getSide(i),h=[l,...m||(u===l||!g?[getOppositePlacement(l)]:getExpandedPlacements(l))],x=await detectOverflow(t,p),y=[];let w=(null==(n=o.flip)?void 0:n.overflows)||[];if(c&&y.push(x[u]),f){const{main:e,cross:t}=getAlignmentSides(i,r,await(null==a.isRTL?void 0:a.isRTL(s.floating)));y.push(x[e],x[t])}if(w=[...w,{placement:i,overflows:y}],!y.every((e=>e<=0))){var v,b;const e=(null!=(v=null==(b=o.flip)?void 0:b.index)?v:0)+1,t=h[e];if(t)return{data:{index:e,overflows:w},reset:{skip:!1,placement:t}};let n="bottom";switch(d){case"bestFit":{var P;const e=null==(P=w.slice().sort(((e,t)=>e.overflows.filter((e=>e>0)).reduce(((e,t)=>e+t),0)-t.overflows.filter((e=>e>0)).reduce(((e,t)=>e+t),0)))[0])?void 0:P.placement;e&&(n=e);break}case"initialPlacement":n=l}return{reset:{placement:n}}}return{}}}};function getSideOffsets(e,t){return{top:e.top-t.height,right:e.right-t.width,bottom:e.bottom-t.height,left:e.left-t.width}}function isAnySideFullyClipped(e){return sides.some((t=>e[t]>=0))}const hide=function(e){let{strategy:t="referenceHidden",...n}=void 0===e?{}:e;return{name:"hide",async fn(e){const{rects:i}=e;switch(t){case"referenceHidden":{const t=getSideOffsets(await detectOverflow(e,{...n,elementContext:"reference"}),i.reference);return{data:{referenceHiddenOffsets:t,referenceHidden:isAnySideFullyClipped(t)}}}case"escaped":{const t=getSideOffsets(await detectOverflow(e,{...n,altBoundary:!0}),i.floating);return{data:{escapedOffsets:t,escaped:isAnySideFullyClipped(t)}}}default:return{}}}}};function convertValueToCoords(e,t,n,i){void 0===i&&(i=!1);const o=getSide(e),r=getAlignment(e),l="x"===getMainAxisFromPlacement(e),a=["left","top"].includes(o)?-1:1;let s=1;"end"===r&&(s=-1),i&&l&&(s*=-1);const c="function"===typeof n?n({...t,placement:e}):n,{mainAxis:f,crossAxis:m}="number"===typeof c?{mainAxis:c,crossAxis:0}:{mainAxis:0,crossAxis:0,...c};return l?{x:m*s,y:f*a}:{x:f*a,y:m*s}}const offset=function(e){return void 0===e&&(e=0),{name:"offset",options:e,async fn(t){const{x:n,y:i,placement:o,rects:r,platform:l,elements:a}=t,s=convertValueToCoords(o,r,e,await(null==l.isRTL?void 0:l.isRTL(a.floating)));return{x:n+s.x,y:i+s.y,data:s}}}};function getCrossAxis(e){return"x"===e?"y":"x"}const shift=function(e){return void 0===e&&(e={}),{name:"shift",options:e,async fn(t){const{x:n,y:i,placement:o}=t,{mainAxis:r=!0,crossAxis:l=!1,limiter:a={fn:e=>{let{x:t,y:n}=e;return{x:t,y:n}}},...s}=e,c={x:n,y:i},f=await detectOverflow(t,s),m=getMainAxisFromPlacement(getSide(o)),d=getCrossAxis(m);let g=c[m],p=c[d];if(r){const e="y"===m?"bottom":"right";g=within(g+f["y"===m?"top":"left"],g,g-f[e])}if(l){const e="y"===d?"bottom":"right";p=within(p+f["y"===d?"top":"left"],p,p-f[e])}const u=a.fn({...t,[m]:g,[d]:p});return{...u,data:{x:u.x-n,y:u.y-i}}}}},limitShift=function(e){return void 0===e&&(e={}),{options:e,fn(t){const{x:n,y:i,placement:o,rects:r,middlewareData:l}=t,{offset:a=0,mainAxis:s=!0,crossAxis:c=!0}=e,f={x:n,y:i},m=getMainAxisFromPlacement(o),d=getCrossAxis(m);let g=f[m],p=f[d];const u="function"===typeof a?a({...r,placement:o}):a,h="number"===typeof u?{mainAxis:u,crossAxis:0}:{mainAxis:0,crossAxis:0,...u};if(s){const e="y"===m?"height":"width",t=r.reference[m]-r.floating[e]+h.mainAxis,n=r.reference[m]+r.reference[e]-h.mainAxis;g<t?g=t:g>n&&(g=n)}if(c){var x,y,w,v;const e="y"===m?"width":"height",t=["top","left"].includes(getSide(o)),n=r.reference[d]-r.floating[e]+(t&&null!=(x=null==(y=l.offset)?void 0:y[d])?x:0)+(t?0:h.crossAxis),i=r.reference[d]+r.reference[e]+(t?0:null!=(w=null==(v=l.offset)?void 0:v[d])?w:0)-(t?h.crossAxis:0);p<n?p=n:p>i&&(p=i)}return{[m]:g,[d]:p}}}},size=function(e){return void 0===e&&(e={}),{name:"size",options:e,async fn(t){const{placement:n,rects:i,platform:o,elements:r}=t,{apply:l,...a}=e,s=await detectOverflow(t,a),c=getSide(n),f=getAlignment(n);let m,d;"top"===c||"bottom"===c?(m=c,d=f===(await(null==o.isRTL?void 0:o.isRTL(r.floating))?"start":"end")?"left":"right"):(d=c,m="end"===f?"top":"bottom");const g=max(s.left,0),p=max(s.right,0),u=max(s.top,0),h=max(s.bottom,0),x={height:i.floating.height-(["left","right"].includes(n)?2*(0!==u||0!==h?u+h:max(s.top,s.bottom)):s[m]),width:i.floating.width-(["top","bottom"].includes(n)?2*(0!==g||0!==p?g+p:max(s.left,s.right)):s[d])};return null==l||l({...x,...i}),{reset:{rects:!0}}}}},inline=function(e){return void 0===e&&(e={}),{name:"inline",options:e,async fn(t){var n;const{placement:i,elements:o,rects:r,platform:l,strategy:a}=t,{padding:s=2,x:c,y:f}=e,m=rectToClientRect(l.convertOffsetParentRelativeRectToViewportRelativeRect?await l.convertOffsetParentRelativeRectToViewportRelativeRect({rect:r.reference,offsetParent:await(null==l.getOffsetParent?void 0:l.getOffsetParent(o.floating)),strategy:a}):r.reference),d=null!=(n=await(null==l.getClientRects?void 0:l.getClientRects(o.reference)))?n:[],g=getSideObjectFromPadding(s);return{reset:{rects:await l.getElementRects({reference:{getBoundingClientRect:function(){var e;if(2===d.length&&d[0].left>d[1].right&&null!=c&&null!=f)return null!=(e=d.find((e=>c>e.left-g.left&&c<e.right+g.right&&f>e.top-g.top&&f<e.bottom+g.bottom)))?e:m;if(d.length>=2){if("x"===getMainAxisFromPlacement(i)){const e=d[0],t=d[d.length-1],n="top"===getSide(i),o=e.top,r=t.bottom,l=n?e.left:t.left,a=n?e.right:t.right;return{top:o,bottom:r,left:l,right:a,width:a-l,height:r-o,x:l,y:o}}const e="left"===getSide(i),t=max(...d.map((e=>e.right))),n=min(...d.map((e=>e.left))),o=d.filter((i=>e?i.left===n:i.right===t)),r=o[0].top,l=o[o.length-1].bottom;return{top:r,bottom:l,left:n,right:t,width:t-n,height:l-r,x:n,y:r}}return m}},floating:o.floating,strategy:a})}}}}};exports.arrow=arrow,exports.autoPlacement=autoPlacement,exports.computePosition=computePosition,exports.detectOverflow=detectOverflow,exports.flip=flip,exports.hide=hide,exports.inline=inline,exports.limitShift=limitShift,exports.offset=offset,exports.rectToClientRect=rectToClientRect,exports.shift=shift,exports.size=size;